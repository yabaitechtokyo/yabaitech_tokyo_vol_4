@import: ../class/yabaitech
@require: itemize
@require: code

module MasWag : sig

  val article : block-text

end = struct

let bibliography = []

let article = '<
    +chapter ?:(`maswag-article`)
    (|
        bibliography = bibliography;
        title = {複数マシンでの実験を Ansible とかでシュっとした話 — 実験編};
        author = {MasWag};
    |)
    <
    +section{はじめに} <
    +p {
      皆さん実験ぶん回してますか？アルゴリズムを設計する人は勿論ですが、そうでない人も諸々のチューニングをして高速化をするとき、複数手法を比較して選定するとき、実験することは少なくないと思います。実験すると言うのは簡単ですが、色々な組み合わせで試そうとするとかなり長い時間がかかることもあるので、あまり気軽に実験を回せない人も少なくないと思います。
    }
    +p {
      しかし今はクラウドコンピューティングの時代です! 各マシンで完全に独立な実験を回す場合、N 台のマシンで実験を回せば 基本的には 1/N の時間で実験が終わることになります。特に Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform (GCP)等 クラウドの場合、多くの場合料金計算が 時間 ${\times} 台数なので、 台数を増やしてもその分時間が減れば、なんと料金的には変わらないです。
    }
    +p {
      とは言ったものの複数台のマシンで大量に実験を回すのは一苦労です。実験するマシンの調達、実験するマシンの環境構築、実験タスクの各マシンへの分配、実験結果の回収方法、等々考える必要のある作業は多数あります。この辺りの作業で手間取ると無駄にクラウドの料金が増えてしまうので悲しいです。一方で、よくあるクラウドでの複数台管理についての情報は、「同じ働きをする」マシンを複数台立ててロードバランサ等でタスクを分配する、Webアプリケーション向けのものが殆どなので、そのまま並列実験に適用できないことが多いです。
    }
    +p {
      この文章では、複数マシンで実験を回す方法についての説明をします。内容としてはクラウドを意識はしていますが、大半の内容はオンプレミス環境などでも動作するはずです。特に特定のクラウドに特化した話は全くしていません。例えばAWSではオンデマンドインスタンスで所謂「定価」で計算資源を買うよりも、スポットインスタンスでオークション形式で買った方が安いですが、そういった話はしません。また、この文章で説明している手法は単なる一例にすぎません。「僕の考えた最強の手法」ですらなく、今回の実験をそれなりの労力で「シュっとさせた」というだけなので改善の余地は多いにあります。一方で他の人がこういう実験をどういう風に回しているのかを知りたい、というニーズに答えられていれば幸いです。
    }
    +subsection{おことわり} <
    +p {
      今回の文章中に挙げているスクリプトですが、比較的やっつけで書いたものも少なくないのでポータビリティについてはあんまり自信がないです。特に Arch Linux や macOS + Homebrew などの、比較的最新版に近いコマンドラインツールがインストールされる環境で確動作確認を行なっているので、ややバージョンの古めのUbuntuなどでは上手く動作しないかもしれません。
    }
    +p {
      関連した本やブログ記事などがあれば良いのですが、筆者の知る限りでは似たことをやっている文書は見つかりませんでした。御存じの方が居たら教えていただけると参考になります。また技術選定については完全に筆者の好みです。他の例えば全体的にpythonに統一する、など別の方法も可能ですし、そういった方法と比べて今回の方法が優れているかどうかは一概には言えないでしょう。
    }
    >
    >
    +section{基本方針} <
    +p {
      今回の実験ではおおよそ以下の様なことを基本方針としています。
    }
    +listing{
    *  できるだけ自動化させるが、諸々のコストが大きい場合は手動作業も厭わない (KISSの原則)
    *  できるだけ実験を行なった環境・コマンドの情報を残しておく (再現性の担保)
    }
    +subsection{できるだけ自動化させるが、諸々のコストが大きい場合は手動作業も厭わない} <
    +p {
      人類皆自動化大好きですし、勿論僕も好きです。特に多数のマシンの管理を行なう際に手動の作業が多いと手間ですし、手動で色々やって時間がかかるとクラウドの従量課金額が増えてしまうのでシンプルに勿体ないです。そもそもこの記事のタイトルにある Ansible はマシンの構成を自動で管理するツールですし、自動化は行ないます。
    }
    +p {
      しかし、だからと言って全ての作業の自動化はこの記事でのゴールではありません。行き過ぎた自動化によって構築するシステムが複雑すぎるものになってしまうのは考えものです。構築するシステムが複雑になればなるほどデバッグは大変になりますし、本当にやりたい実験に到達するまでの時間が長くなってしまいます。今回の最終目的は自分のやりたい実験を簡単に回すことなのでその上で大きな障壁とならない部分はできるだけシンプルに、場合によっては手動作業で行ないます。
    }
    >
    +subsection{できるだけ実験を行なった環境・コマンドの情報を残しておく} <
    +p {
      比較的大規模な実験をする上でとても気がかりなことの一つは、正しい手順で実験をやっているかどうかだと思います。複数の設定で実験をやっていると \code(`git clone`); 等でバージョンを変更するのを忘れる、コンパイルを忘れるなどのオペレーションミスが起きる (または起きていないか段々自信がなくなってくる) と思います。
    }
    +p {
      もう一つの大きな懸念事項は実験環境を忘れてしまうということです。一つ一つの実験について、例えば gcc のコンパイルオプションが \code(`-O3`); だったか \code(`-O2`); だったかを人間が覚えていくのはなかなか難しいですし、自分が書いたソフトウェアの細かいバージョンと実験結果の対応関係は、ちゃんと記録を残しておかないとまずわからなくなってしまうでしょう。
    }
    +p {
      これらの理由で過去に行なった実験自体の正しさに確信が持てない場合、つまり「そういえばこの実験ってどういう環境でやったんだっけ…?」という状況になってしまった場合、最終的には再実験を行なって「正しい」実験を再度行なうことになると思います。大規模な実験となると時間もかかりますし、クラウドで行なうととお金もかかってしまいます。特に時間を置いて新しい環境と比較実験を行ないたい場合には、過去の実験環境の詳細がわかっていない場合には再実験が必要になると思われます。
    }
    +p {
      こういった問題を起こさないためにも、できるだけ実験を行なった環境・コマンドの情報を残しておく、つまり同じ実験を再現させられるようにしておく、ということは今回の実験では重視します。
    }
    >
    >
    +section{イカれたメンバーを紹介するぜ!!} <
    +listing{
    * \emph{マシンの作成} 手動!!
    * \emph{マシンの起動} vmctl!!
    * \emph{構成管理} Ansible!!
    * \emph{実験スクリプト、実験結果の管理} Git!!
    * \emph{対話的な諸々の自動化} expect!!
    * \emph{実験開始・終了のお知らせ} slack!!
    }
    +p {
      以上!!
    }
    +p {
      ここから各登場ツールについて説明をしていきます。なお、最終的なワークフローは 図 hoge の様になります。
    }
    +p {
      file:./figs/flowchart.pdf
    }
    +subsection{vmctl} <
    +p {
      \emph{vmctl} (https://github.com/MasWag/vmctl) は様々な仮想マシンに対して同様のインターフェースで起動、停止などの基本的な操作を行なえる様にした、手製のshell scriptです。「様々な仮想マシン」と言いつつ現状Amazon AWSの EC2 と VirtualBox にしか対応していないですが、原理的にはコマンドラインインターフェースが用意されている仮想マシンであればそれなりの工数で追加できることになっています。
    }
    +p {
      今回は特に複数種類の仮想マシンを扱うこともないと思いますが、単にマシンのidを毎回打ちたくないというだけの理由で使いました。例えばec2だと各マシン (インタンス) に対して \code(`i-1234567890abcdef0`); の様なidが割り振られます。率直に言うとこれは人間が覚えて直接扱うべきものではありません。できるものなら各マシンに役割のわかり安い名前を付けたり、例えば \code(`my_instance1 my_instance2 my_instance3 ...`); の様に連番のマシン名を付けたりしたいです。今回のvmctlの用途は正にこの名前付けです。例えばマシン名が \code(`my_great_instance`); のマシンを起動するのであれば、 \code(`vmctl start my_great_instance`); で起動できますし。特にMachine名が連番である場合は bashの連番展開を使って、例えば \code(`vmctl stop my_instance{1..10}`); の様に使うこともできます。
    }
    +subsubsection{代替品 – Terraform} <
    +p {
      クラウドのマシンを一括で起動・停止するという意味では Terraform を使うこともできます。Terraform は 必要なインスタンス等のインフラストラクチャをテキストで定義して、自動で作成 (apply) ・破棄 (destroy) するツールです。Terraform を使う場合は予め準備しておいたインスタンスを起動・停止するのではなく、毎回新しいインスタンスを作成・破棄することになるので、よりImmutable Infrastructure的なワークフローに向いていると思います。
    }
    >
    >
    +subsection{Ansible} <
    +p {
      \emph{Ansible} (https://www.ansible.com/) は言わずと知れた超有名構成管理ツールで、YAMLでマシンの設定を記述することで、自動で環境構築やデプロイを行えるツールです。今回は必要なソフトウェアのインストールの他に、実験スクリプトや実験用のコードの入っているgitレポジトリの clone/pullとかに使っています。実験対象のプログラムのコンパイル等の定型処理を忘れない、というのも一つの利点ですが、Ansible は複数マシンに対して実行することができるので、特に多くのマシンを扱いたい場合には便利になります。
    }
    +subsubsection{代替品 – 構成管理ツール} <
    +p {
      Ansible 以外にも例えば以下に挙げた様に、構成管理ツールはかなり多数あるので、好きなものを使うと良いと思います。個人的にも Ansible を使っている深い理由はないですし、色々な比較をしているwebページもかなりあるので、ここでは名前を挙げるのみとします。
    }
    +listing{
    *  itamae
    *  Chef
    *  Puppet
    }
    >
    >
    +subsection{Git} <
    +p {
      \emph{Git} (https://git-scm.com/) は有名、というか2020年現在ほぼデファクトスタンダードとなっている分散バージョン管理システムです。今回はGitを実験内容を記述したスクリプトの管理だけではなく、実験結果のテキストファイルの管理にも使っています。実験スクリプトはソフトウェアなので当然Gitでの版管理は便利ですが、実験結果もGitで管理しているのは、複数マシンで実験を行なった結果、生成されたファイルが衝突したときにちゃんとマージできるからです。この、「複数マシンで同時に実験した結果を上手い具合にマージできる」という点が並列実験システムにおいてかなり重要であると考えています。
    }
    +subsubsection{代替品 – バージョン管理システム} <
    +p {
      Git以外にもMercurialやBazaar、darcsなど様々な分散バージョン管理システムがあるので、これも好きなものを選ぶと良いと思います。一方バージョン管理システムと言っても、RCSの様にローカルで完結しているものや、Subversionの様に集中型で気軽にマージができないものは向かないと思います。
    }
    +p {
      複数マシン間でデータを同期させたいだけであれば、例えば rsync でも良い様に思えますが、過去の変更の情報をちゃんと追えなかったりmergeがちゃんとできないので、しっかりとワークフローを練らないと代替は難しいと思います。
    }
    >
    +subsubsection{速度面での課題} <
    +p {
      Gitはかなり大きなレポジトリを扱えますが、実験ログが膨大になったり、特に巨大なバイナリファイルを多数扱う必要が出てくると Git が思う様に動かなくなっていきます。具体的には例えば \code(`git merge`); などにかなりの時間がかかる様になります。これについては、 (筆者は試したことがないですが) 例えば Git-LFS を使うことで全体のワークフローとの噛み合わせを保ちつつ巨大なファイルを扱える様になると思われます。
    }
    >
    >
    +subsection{expect} <
    +p {
      \emph{expect} (https://core.tcl-lang.org/expect/index) はTcl製の対話的なCUIプログラムの自動化ツールです。普通のCUIの処理の自動化なら例えばシェルスクリプトで行なえますが、例えばsshやftp等で必要となる対話的な操作の自動化をシェルスクリプトで行なうのは至難の技ですが、expectを使うことで比較的用意に自動化することができます。今回は実験スクリプトをリモートで実行する際にexpectを使いました。ansible でも似たことができるかもしれないですが、知らないうちにオーバーヘッドが載って実験結果に影響があると良くないので、できるだけ簡素な方法ということでexpectを使いました。
    }
    +subsubsection{代替品} <
    +p {
      今回はオリジナルのTcl版のexpectを使いましたが、今ではpythonやrubyなどでもexpectの移植版や類似のものが出ているので、そちらを使っても良いでしょう。
    }
    >
    >
    +subsection{slack} <
    +p {
      \emph{slack} (https://slack.com) は有名チャットツールで、http経由で簡単に外部から通知を送ることができます。今回は実験終了の通知を送るために使いました。実験の進め方とは関係ないですが、実験が終わるのかを逐一見に行くのは精神衛生上よろしくないですし、今回のワークフローの中では重要だと考えます。
    }
    +subsubsection{代替品} <
    +p {
      今回はslackを単に通知を送るためだけに使っているので、特にslackである必要もないですし、普段slackを使っていない人がわざわざ使う必要はないでしょう。他のチャットツールを使っても良いですし、それこそメールで通知を送っても大丈夫です。
    }
    >
    >
    >
    +section{マシン構成パート} <
    +p {
      ここから、マシン構成パートの流れについて説明していきます。
    }
    +subsection{マシンの作成・初期設定: 手動} <
    +p {
      まず始めに実験に使うマシンを作成して、ユーザ設定や最低限必要な設定などを行ないます。「マシンの初期設定」というとかなり広い範囲のことが含まれそうですが、環境構築スクリプトをもう一度回せば同じ環境を構築できる様にしたいので、できる限り手動操作を減らすと良いでしょう。例えば今後必要となるユーザやSSH鍵の配置といったアクセス周りの設定や、今後の実験で必要なソフトウェアで、毎回インストールするのが時間や手間の上で大変なものだけを設定するのが良いと思います。逆にインストールに時間や手間がかかるソフトウェアを毎回インストールするのは大変なので、そういったソフトウェアのインストールもこの段階で済ませてしまうと良いと思います。
    }
    +subsubsection{アレンジ例} <
    +p {
      今回はメインの実験で MATLABが必要で、ライセンス管理の自動化が厄介なので、 MATLABのインストールまでを手動でやりました。必要なソフトウェアにライセンス等の問題が全くないのであればこの工程は自動化しても良いと思います。例えば、 Packer で予め必要なマシンイメージを作っておいて、必要な時に必要なだけ Terraform とかでマシンを作って、不要になったらすぐ壊す、ということが可能です。
    }
    +p {
      また、初期設定に手動部分がどうしても必要な場合でも、自動設定の部分と手動設定の部分を分離することで、Packerなどを部分的に用いるワークフローにすることも良いと思います。
    }
    >
    >
    +subsection{vmctl の設定ファイルを書く} <
    +p {
      次にvmctlを設定します。vmctlの設定はjsonで書かれた設定ファイル (\code(`~/.vmctl.json`);) で行ないます。基本的には 1) インスタンス名、 2) インスタンスの種類 (ec2等)、 3) インスタンス ID、 が書かれたjsonファイルで、例えば以下の様になります。
    }
    +code(`
    [
        {
            "name": "marisa",
            "type": "ec2",
            "instance_id": "i-0fsdfd13c7bf3d6b6",
            "profile": "sample"
        },
        {
            "name": "reimu",
            "type": "virtual_box",
            "instance_id": "95a2dsfdb-0dfbf-40bb-bf15-92df8d07c7dc"
        }
    ]
    `);
    +p {
      インスタンス数が少ない場合は手書きしても大丈夫ですが、多数のインスタンスを扱う場合は設定ファイルを自動で生成したくなると思います。Amazon EC2については 例えば次のコマンドで生成することができます。
    }
    +code(``
    aws ec2 describe-instances --query 'Reservations[\*].Instances[\*].[InstanceId,Tags[?Key==`Name`].Value|[0]]|[]' |
        jq --arg profile "$PROFILE" 'map({"type": "ec2", "instance_id": .[0], "name": .[1]})' > ~/.vmctl.json
    ``);
    >
    >
    +section{実験環境設定パート} <
    +p {
      次は実験環境設定パートについて説明していきます。
    }
    +subsection{実験環境構築用の Ansible playbook を書く} <
    +p {
      まず始めに実験環境構築用の Ansible playbook を書きます。ここでは、データセットの準備や実験対象のプログラムのコンパイルや、験用Gitレポジトリの準備等に加えて、後で必要となるaws-cliやslackに通知を送るためのスクリプトの設定等も行ないます。細かい内容についてはさておき、例えば以下の様な YAMLファイル で設定を行なうことができます。
    }
    +subsubsection{例} <
    +code(``
    - hosts: aws
      user: ubuntu
      tasks:
        - name: Install required packages
          apt:
            pkg:
              - awscli
              - unzip
              - ...
          become: yes

        - name: configure aws-cli
          file:
            dest: ~/.aws/
            state: directory

        - name: configure aws-cli
          copy:
            src: ~/.aws/config
            dest: ~/.aws/config

        - name: configure aws-cli
          copy:
            src: ~/.aws/credentials
            dest: ~/.aws/credentials

        - name: Download and extract the dataset
          unarchive:
            dest: /tmp
            src: http://example.com/dataset.zip
            remote_src: yes

        - name: clone bar-experiments
          git:
            repo: "git@example.com:foo/bar-experiments.git"
            dest: /home/ubuntu/bar-experiments

        - name: setup notif_my_slack
          file:
            dest: ~/bin/
            state: directory

        - name: setup notif_my_slack
          shell: m4 -DHOST=$(/usr/bin/aws ec2 describe-instances --instance-ids  "$(cat /var/lib/cloud/data/instance-id)" --query 'Reservations[\*].Instances[\*].Tags[?Key==`Name`].Value' | tr -d [] | xargs) /home/ubuntu/bar-experiments/utils/notif_my_slack.m4 > ~/bin/notif_my_slack

        - name: setup notif_my_slack
          file:
            path: ~/bin/notif_my_slack
            mode: '0755'
    ``);
    >
    +subsubsection{\code(`notif_my_slack.m4`);} <
    +p {
      環境設定用のAnsible notebookの中で \code(`notif_my_slack.m4`); が出てきたので説明をします。 \code(`notif_my_slack.m4`); はm4のコードです。今回m4は \code(`notif_my_slack`); というシェルスクリプトを生成するためのプリプロセッサとして使っています。m4自体もチューリング完全なプログラミング言語ですが、今回は単に文字列 \code(`HOST`); をEC2でのインスタンス名に置換するためだけに使っています。なお最後の \code(`https://hooks.slack.com/services/<The given ID>`); はslackで外部から通知を飛ばす用のURL (Incoming Webhooksのエンドポイント) です。取得法などについては slack, Incoming Webhooks, 等で検索すると詳しい説明が出てくるので省略します。
    }
    +code(``
    #!/bin/sh

    if [ $# -gt 0 ]; then
      curl -X POST -H 'Content-type: application/json' --data '{"text":"'"$\*"' from HOST"}' https://hooks.slack.com/services/<The given ID>
    else
      curl -X POST -H 'Content-type: application/json'  --data  `"{\"text\":\"###From' HOST###\n$(cat)\"}" https://hooks.slack.com/services/<The given ID>
    fi
    ``);
    >
    >
    +subsection{実験スクリプトを書く} <
    +p {
      「実験スクリプトを書く」というとただ一言で終わってしまうので、個人的に採用している実験用Gitレポジトリの構成についても説明します。実験用にGitレポジトリを作っている理由は前述の様に複数マシンで同時に実験した結果を上手い具合にマージできるからですが、できるだけマージ時に衝突しないように図の様なディレクトリ構成を採用しています。ざっくり言うと気をつけている点は以下の点です。
    }
    +listing{
    *  各実験に個別のスクリプト等は各実験用のディレクトリに入れる。逆に共通のスクリプト等は \code(`/utils`); 以下に格納する
    *  各実験にtimestamp付きのIDを割り振って衝突しない様にする
    *  実験用スクリプト名は常に \code(`run.sh`);
    *  各ディレクトリには実験の説明を書いた \code(`README.md`); を書く
    }
    +code(`
    ├── <20200102-1234-experiment1>
    │   ├── run.sh
    │   ...
    ├── <20200203-2345-experiment2>
    │   ├── run.sh
    │   ...
    └── utils
        ├── setup.sh
        ├── teardown.sh
        ├── notif_my_slack.m4
        ...
    `);
    +p {
      それではそれぞれのファイルについて説明していきます。なお、 \code(`notif_my_slack.m4`); の説明はSection ???を参照してください。
    }
    +subsubsection{run.sh} <
    +p {
      \code(`run.sh`); は実験用のメインになるスクリプトです。ファイル名を \code(`run.sh`); にするのは自動化を容易にするためです。 \code(`run.sh`); での処理はざっくり書くと以下の様になります。
    }
    +listing{
    *  準備用のスクリプトである \code(`setup.sh`); (後述) を呼ぶ
    *  実験本体の処理
    *  終了処理用のスクリプトである \code(`teardown.sh`); (後述) を呼ぶ
    }
    >
    +subsubsection{setup.sh} <
    +p {
      さて、 \code(`setup.sh`); は準備用のスクリプトです。とはいえやっている内容は以下の二つだけになります。
    }
    +listing{
    *  実験対象のプログラム等、外部で使っているgitレポジトリののバージョンをファイルに保存
    *  slackに実験開始のお知らせをする
    }
    +code(`
    git --git-dir ~/<Program>/.git rev-parse HEAD > git-hash

    readonly experiment=$(pwd | sed 's:.\*/::')

    notif_my_slack <<EOF
    experiment ${experiment} started.
    The arguments: $@
    EOF
    mkdir -p results
    `);
    >
    +subsubsection{teardown.sh} <
    +p {
      次に実験終了時のスクリプト、 \code(`teardown.sh`); です。ざっくり言うとやっている内容は以下の三点になります。
    }
    +listing{
    *  実験内容を \code(`git commit`); する
    *  slackに実験終了のお知らせをする
    *  実験に使ったインスタンスを停止する
    }
    +code(`
    readonly experiment=$(pwd | sed 's:.\*/::')

    # Synchronize the filesystem and wait for 60 sec.
    sync
    sleep 60
    git add .
    git commit -m "experiment ${experiment} $\* finished"
    notif_my_slack "experiment_${experiment}_finished"
    /usr/bin/aws ec2 stop-instances --instance-ids  "$(cat /var/lib/cloud/data/instance-id)"
    `);
    >
    >
    >
    +section{今後の課題} <
    +subsection{Gitでbranchを活用してmergeをlocalでやるようにすると、syncを並列化できる (はず)} <
    >
    +subsection{スクリプトのポータビリティを上げる (POSIX shell で動く)} <
    +subsubsection{今のスクリプトはdashとかでは動かない} <
    >
    >
    >
    +section{◇ (Eventually) 回予告} <
    +subsection{いかがだったでしょうか} <
    >
    +subsection{今回は実験を回すところまでやった} <
    >
    +subsection{実験を回したら結果を回収して解析する必要がある} <
    >
    +subsection{自動解析も結構工夫のしがいがある} <
    >
    +subsection{どの実験結果を最終的に比較するか、はベタ書きしない} <
    +subsubsection{例えば表にして比較する実験設定をスクリプトにベタ書きしない。できるだけDRYにする。} <
    >
    >
    +subsection{◇ (Eventually) 回 は解析パート} <
    >
    >
    >
>

end
