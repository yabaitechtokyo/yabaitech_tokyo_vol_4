@import: ../../class/yabaitech
@require: itemize

module Wasabiz : sig

  val article : block-text

end = struct

let bibliography = []

let metadata = (|
    bibliography = bibliography;
    title = {Let's verify your C program!};
    author = {wasabiz};
|)

let article = '<
+chapter ?:(`wasabiz-article`) (metadata) <
+section{はじめに}<
+p{
    この記事ではC言語で書かれたプログラムの正しさを証明する手法について解説します．
    Cのプログラムの性質を証明すると言っても世の中にはいろいろな手法があります．
    とりあえず挙げてみるなら大まかに以下の三つの方針がありえるでしょうか．
}
+listing{
    * すでに存在する証明をもとに絶対に正しいCプログラムを生成する．(プログラム抽出)
    * Cプログラムを入れると欲しい性質が満たされているか自動で検査してくれるツールを使う（自動検証）
    * Cプログラムを別の言語に変換して変換後のプログラムに証明をつける（自動/半自動検証）
}
+p{
    一つ目の手法でよく使われるのはCoqとかでしょうか．
    Coqそれ自体は依存型付のプログラミング言語でなんか証明も書けるようなものです．
    Coqで書ける(プログラマー的に興味のある)証明はこのCoqに内蔵された依存型付言語に対するものなのですが，CoqにはそのようなCoqプログラムを別の言語に(挙動を保ったまま)変換するextractionという機能が備わっています．
    そのため欲しいCプログラムと同じ挙動をするプログラムをCoq上で記述してCoq上でそれについての証明を書きCプログラムに変換するということが出来ます．
    （たぶんデフォルトではCへの抽出に対応していないのでいろいろと頑張る必要がある．）
    この方法はCoqというとても整備された環境で証明が書けるという利点はあるのですが既に出来上がっているCプログラムの検証をするには向いていません．
}
+p{
    二つ目の手法はよく研究されている手法です．
    こちらは一つ目の手法と異なりすでに出来上がっているCプログラムの検証が可能です．
    有名なところだとVeriFastやFacebook Inferなどがあります．
    C言語に限らなければDafnyやJava PathFinderが有名でしょうか．
    とはいえ上にあげた3つはそれぞれ理論的/実装的に異なるものなので一概には比較できません．
    VeriFastの場合はZ3を用いたInductive Predicate付きのSeparation Logicを使った仕様記述とZ3をベースにしたSymbolic Executionによる検証を実装しています．
    VeriFastはすでにあるCプログラムに対して自動で検証ができしかも速い(らしい)という意味でとても良さそうなのですが，一方で仕様記述言語が独自のため表現能力に限界があるという点と自動証明がうまく行かなかった場合につらい点がイマイチです．
    Inferも同じくSeparation Logicベースでメモリのバグなどを自動で検出してくれますが入力に仕様を与えられないのと健全性がない(偽陽性がでる)点はイマイチです．
}
+p{
    三つ目の手法はややトリッキーですがおそらく最も現実的な手法です．
    最も有名なのはFrama-Cです．
    Frama-C は典型的にはCプログラムを WhyML と呼ばれるMLライクな言語に変換します．
    WhyMLはWhy3というプロジェクトの成果で，Why3ではWhyMLを検証するための様々なツール(例えばCoqで証明するためのライブラリや自動検証ツールなど)を提供しています．
}
+p{
    本記事で扱う内容は三つ目の手法です．
    ただし使うツールはFrama-C + Why3ではなく c-parser と呼ばれるツールです．
    c-parserはseL4という証明付きマイクロカーネルを開発する上で作成されたツールです．
    seL4はそれ自体が非常によくできておりカーネル開発者的視点からもプログラム検証的視点からもとても興味深いプロジェクトなのですが，それは一旦さておきc-parserはCで書かれたマイクロカーネルをSimplという言語に翻訳するためのツールです．
    SimplはWhile言語に毛が生えたようなもので，WhyMLとは異なり手続き型の側面を強く残しています．
    Why3とSimplの違いはソフトウェアスタックの大きさです．
    Why3(+Frama-C)は巨大かつレイヤーが多重になった構成ですがあSimpl(+c-parser)はすべてがIsabelle/HOL前提で作られておりIsabelle/HOLの中だけで完結するように作られています．
    そのため盲目的に信頼しなければならないコンポーネントが少ないという特徴があります．
    また，Isabelleの既存の資産を最大限に活用することができます．
    Why3の方がさまざまなプラグインを持っており機能自体は多いのですが，Simpl(+c-parser)の思想とseL4の証明に使われたという実績を考慮してこちらを採用することにしました．
}
>
>
>

end
