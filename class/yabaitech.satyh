% -*- coding: utf-8 -*-
@require: pervasives
@require: gr
@require: list
@require: option
@require: math
@require: color
@require: vdecoset
@require: footnote-scheme
@require: table
@import: ../base/block
@import: ../base/color-ext
@import: ../base/fn
@import: ../base/image
@import: ../base/inline
@import: ../base/int
@import: ../base/pager
@import: ../base/tuple
@import: ../base/typeset/font

@import: bibliography
@import: colophon
@import: table-of-contents
@import: title

module Book : sig

  val document : 'a -> block-text -> document
    constraint 'a :: (|
      title: string;
      date: string;
      venue: string;
      author: string;
      email: string;
      website: string;
      publisher: string;
    |)

  val font-latin-roman  : string * float * float
  val font-latin-italic : string * float * float
  val font-latin-bold   : string * float * float
  val font-latin-mono   : string * float * float
  val font-cjk-mincho   : string * float * float
  val font-cjk-gothic   : string * float * float
  val set-latin-font : (string * float * float) -> context -> context
  val set-cjk-font   : (string * float * float) -> context -> context
  val get-latin-font-size : context -> length
  val get-cjk-font-size : context -> length
  direct \ref : [string] inline-cmd
  direct \ref-page : [string] inline-cmd
  direct \ref-chapter : [string] inline-cmd
  direct \ref-section : [string] inline-cmd
  direct \ref-subsection : [string] inline-cmd
  direct \ref-definition : [string] inline-cmd
  direct \ref-theorem : [string] inline-cmd
  direct \ref-lemma : [string] inline-cmd
  direct \ref-corollary : [string] inline-cmd
  direct \ref-hypothesis : [string] inline-cmd
  direct \ref-example : [string] inline-cmd
  direct \ref-figure : [string] inline-cmd
  direct \ref-table : [string] inline-cmd
  direct \index : [string; inline-text?; inline-text] inline-cmd
  direct \cite : [string list] inline-cmd
  direct \figure : [string?; inline-text; block-text] inline-cmd
  direct \table : [string?; inline-text; block-text] inline-cmd
  direct +p : [inline-text] block-cmd
  direct +topic : [inline-text; inline-text] block-cmd
  direct +chapter : [string?; inline-text?; 'a; block-text] block-cmd
    constraint 'a :: (|
      title : inline-text;
      author : inline-text;
      bibliography : (string * bib-item) list;
    |)

  direct +section : [string?; inline-text; block-text] block-cmd
  direct +subsection : [string?; inline-text; block-text] block-cmd
  direct +subsubsection : [inline-text; block-text] block-cmd
  direct +definition : [inline-text?; string?; inline-text] block-cmd
  direct \definition : [inline-text?; string?; inline-text] inline-cmd
  direct +theorem : [inline-text?; string?; inline-text] block-cmd
  direct \theorem : [inline-text?; string?; inline-text] inline-cmd
  direct +example : [inline-text?; string?; inline-text] block-cmd
  direct \example : [inline-text?; string?; inline-text] inline-cmd
  direct +notation : [inline-text?; string?; inline-text] block-cmd
  direct \notation : [inline-text?; string?; inline-text] inline-cmd
  direct +lemma : [inline-text?; string?; inline-text] block-cmd
  direct \lemma : [inline-text?; string?; inline-text] inline-cmd
  direct +corollary : [inline-text?; string?; inline-text] block-cmd
  direct \corollary : [inline-text?; string?; inline-text] inline-cmd
  direct +hypothesis : [inline-text?; string?; inline-text] block-cmd
  direct \hypothesis : [inline-text?; string?; inline-text] inline-cmd

  direct +proof : [inline-text?; inline-text] block-cmd
  direct \proof : [inline-text?; inline-text] inline-cmd
  direct \emph : [inline-text] inline-cmd
  direct \dfn : [inline-text] inline-cmd
  direct \roman : [inline-text] inline-cmd
  direct \footnote : [inline-text] inline-cmd

end = struct

  let generate-fresh-label =
    let-mutable count <- 0 in
      (fun () -> (
        let () = count <- !count + 1 in
          `generated:` ^ (arabic (!count))
      ))


  let-inline ctx \ref key =
    let opt = get-cross-reference (key ^ `:num`) in
    let it = embed-string (Option.from `?` opt) in
      read-inline ctx it


  let-inline ctx \ref-page key =
    let opt = get-cross-reference (key ^ `:page`) in
    let it = embed-string (Option.from `?` opt) in
      read-inline ctx it


  let-inline ctx \ref-chapter key =
    let opt = get-cross-reference (`chapter:` ^ key ^ `:num`) in
    let it = embed-string (Option.from `?` opt) in
      read-inline ctx {第#it;章}


  let-inline ctx \ref-section key =
    let opt = get-cross-reference (`section:` ^ key ^ `:num`) in
    let it = embed-string (Option.from `?` opt) in
      read-inline ctx {#it;節}


  let-inline ctx \ref-subsection key =
    let opt = get-cross-reference (`subsection:` ^ key ^ `:num`) in
    let it = embed-string (Option.from `?` opt) in
      read-inline ctx {#it;節}


  let-inline ctx \ref-figure key =
    let opt = get-cross-reference (`figure:` ^ key ^ `:num`) in
    let it = embed-string (Option.from `?` opt) in
      read-inline ctx {図#it;}


  let-inline ctx \ref-table key =
    let opt = get-cross-reference (`table:` ^ key ^ `:num`) in
    let it = embed-string (Option.from `?` opt) in
      read-inline ctx {表#it;}


  let-mutable index-list <- []


  let-inline ctx \index s ?:itopt it =
    let it-index =
      match itopt with
      | None           -> it
      | Some(it-index) -> it-index
    in
      hook-page-break (fun pginfo _ -> (
        let pageno = pginfo#page-number in
        index-list <- (s, it-index, pageno) :: !index-list
      )) ++ read-inline ctx it


  let font-size-normal  = 11pt
  let font-size-title   = 32pt
  let font-size-author  = 16pt
  let font-size-chapter = 24pt
  let font-size-chapter-subtitle = 16pt
  let font-size-chapter-author = 18pt
  let font-size-section = 18pt
  let font-size-subsection = 16pt

  let section-top-margin = 20pt
  let section-bottom-margin = 12pt
  let section-top-padding = 6pt
  let section-bottom-padding = 7pt
  let title-line-margin = 4pt
  let title-line-thickness = 1pt
  let header-line-thickness = 0.5pt
  let header-line-margin-top = 2pt
  let header-line-margin-bottom = 6pt

  let toc-section-indent = 20pt
  let toc-subsection-indent = 40pt

  let font-ratio-latin = 1.
  let font-ratio-cjk = 0.88

  let font-latin-roman  = (`Junicode`   , font-ratio-latin, 0.)
  let font-latin-italic = (`Junicode-it`, font-ratio-latin, 0.)
  let font-latin-bold   = (`Junicode-b` , font-ratio-latin, 0.)
  let font-latin-sans   = (`lmsans`    , font-ratio-latin, 0.)
  let font-latin-mono   = (`lmmono`    , font-ratio-latin, 0.)
  let font-cjk-mincho   = (`ipaexm`    , font-ratio-cjk  , 0.)
  let font-cjk-gothic   = (`ipaexg`    , font-ratio-cjk  , 0.)
  let font-otherscript-roman = (`cmunrm` , font-ratio-latin, 0.)


  let set-latin-font font ctx =
    ctx |> set-font Latin font


  let set-cjk-font font ctx =
    ctx |> set-font HanIdeographic font
        |> set-font Kana           font


  let get-latin-font-size ctx =
    get-font-size ctx *' font-ratio-latin


  let get-cjk-font-size ctx =
    get-font-size ctx *' font-ratio-cjk


  let-inline ctx \roman inner =
    read-inline (ctx |> set-latin-font font-latin-roman) inner


%  let-inline ctx \math-default m =
%    embed-math (ctx |> set-latin-font font-latin-roman) m

  let get-standard-context wid =
    get-initial-context wid (command \math)
      |> set-dominant-wide-script Kana
      |> set-language Kana Japanese
      |> set-language HanIdeographic Japanese
      |> set-dominant-narrow-script Latin
      |> set-language Latin English
      |> set-font Kana           font-cjk-mincho
      |> set-font HanIdeographic font-cjk-mincho
      |> set-font Latin          font-latin-roman
      |> set-font OtherScript    font-otherscript-roman
      |> set-math-font `Asana-Math`
      |> set-hyphen-penalty 1000
      |> set-space-ratio 0.275 0.08 0.12


  let-mutable ref-float-boxes <- []


  let height-of-float-boxes pageno =
%    let () = display-message `get height` in
    (!ref-float-boxes) |> List.fold-left (fun h (pn, bb) -> (
      if pn < pageno then h +' (get-natural-length bb) else h
    )) 0pt


  let make-chapter-title ctx =
    ctx |> set-font-size font-size-chapter
        |> set-font Latin font-latin-bold
        |> set-cjk-font font-cjk-gothic

  let make-chapter-subtitle ctx =
    ctx |> set-font-size font-size-chapter-subtitle
        |> set-font Latin font-latin-bold
        |> set-cjk-font font-cjk-gothic

  let make-chapter-author ctx =
    ctx |> set-font-size font-size-chapter-author
        |> set-font Latin font-latin-bold
        |> set-cjk-font font-cjk-gothic

  let make-section-title ctx =
    ctx |> set-font-size font-size-section
        |> set-font Latin font-latin-bold
        |> set-cjk-font font-cjk-gothic


  let make-subsection-title ctx =
    ctx |> set-font-size font-size-subsection
        |> set-font Latin font-latin-bold
        |> set-cjk-font font-cjk-gothic
  
  let align-ib-left ib = ib ++ inline-fil

  let-mutable toc-acc-ref <- []


  let get-cross-reference-number prefix label =
    match get-cross-reference (prefix ^ label ^ `:num`) with
    | None    -> `?`
    | Some(s) -> s


  let get-cross-reference-page prefix label =
    match get-cross-reference (prefix ^ label ^ `:page`) with
    | None    -> `?`
    | Some(s) -> s


  let chapter-heading ctx ib-num-opt ib-title =
    let bb =
      match ib-num-opt with
      | None         -> block-nil
      | Some(ib-num) -> line-break false false ctx (ib-num ++ inline-fil)
    in
      bb +++ line-break false false ctx (ib-title ++ inline-fil) +++ block-skip 36pt

  let chapter-heading-with-author ctx ib-num-opt ib-title ib-subtitle ib-author =
    let bb-num-opt =
      match ib-num-opt with
      | None         -> block-nil
      | Some(ib-num) -> line-break false false ctx (ib-num ++ inline-fil)
    in
    let bb-title = line-break false false ctx (ib-title ++ inline-fil) in
    let bb-subtitle = line-break false false ctx (inline-fil ++ ib-subtitle ) in
    let bb-author = line-break false false ctx (inline-fil ++ ib-author) in
      bb-num-opt +++ bb-title +++ bb-subtitle +++ bb-author +++ block-skip 18pt

  let section-heading ctx ib-heading =
    line-break true false (ctx |> set-paragraph-margin section-top-margin section-bottom-margin) ib-heading


  let-inline ctx \dummy it =
    let ib = read-inline (ctx |> set-text-color Color.white) it in
    let w = get-natural-width ib in
      ib ++ inline-skip (0pt -' w)

  let-mutable show-page-number-ref <- None
  let make-bb-disable-page-number ctx = ctx
    |> Block.of-inline false false
         (Fn.const (Pager.make-hook (fun _ _ -> (show-page-number-ref <- None))))

  let-inline ctx \cite labels = Bibliography.make-ib-cite ctx labels

  let-mutable num-figure <- 0
  let-mutable num-chapter <- 0
  let-mutable num-section <- 0
  let-mutable num-subsection <- 0
  let-mutable num-theorems <- 0

  let paper-size = UserDefinedPaper(182mm, 257mm)
  let text-origin = (16mm, 30mm)
  let text-width = 150mm
  let text-height = 200mm
  let header-origin = (16mm, 15mm)
  let header-width = text-width
  let footer-origin = (16mm, 240mm)
  let footer-width = text-width
  let footnote-indent = 6mm

  let make-bb-bib-section ctx-bib ctx-doc bibliography =
    match bibliography with
    | [] -> Block.nil
    | bibliography -> 
        let ib-bib-title =
          ctx-doc
          |> make-chapter-title
          |> Inline.read {参考文献}
        in
        let bb-bib-title =
          (ib-bib-title ++ inline-fil)
          |> section-heading ctx-doc
        in
        let bb-bib-main = Bibliography.make-bb-bibs ctx-bib bibliography
        in
        bb-bib-title +++ bb-bib-main

  let chapter-scheme ctx label bibliography title subtitle author inner =
    let txtwid = text-width in
    let () = increment num-chapter in
    let () = num-section <- 0 in
    let () = num-subsection <- 0 in
    let () = num-figure <- 0 in
    let () = num-theorems <- 0 in
    let s-num = arabic (!num-chapter) in
    let () = register-cross-reference (`chapter:` ^ label ^ `:num`) s-num in
    let () = toc-acc-ref <- (TOCElementChapter(label, title, subtitle, author)) :: !toc-acc-ref in
    let ctx-title = make-chapter-title ctx in
    let ctx-subtitle = make-chapter-subtitle ctx in
    let ctx-author = make-chapter-author ctx in
    let ctx-doc =
      get-standard-context txtwid
        |> set-font-size 12pt
        |> set-leading 18pt
        |> set-hyphen-penalty 1000
    in
    let ib-num =
      read-inline ctx-title ({})
        ++ hook-page-break (fun pbinfo _ ->
             register-cross-reference (`chapter:` ^ label ^ `:page`) (arabic pbinfo#page-number))
    in
    let ib-title = (read-inline ctx-title title) in
    let ib-subtitle = match subtitle with
          | None    -> inline-nil
          | Some(st) -> (read-inline ctx-subtitle {―}) ++ (read-inline ctx-subtitle st) ++ (read-inline ctx-subtitle {―}) in
    let ib-author = read-inline ctx-author author in
    let bb-title = chapter-heading-with-author ctx (Some(ib-num)) ib-title ib-subtitle ib-author in
    let bb-inner = read-block ctx inner in

    let () = Bibliography.register-bibs bibliography
    in
    let bb-bib-section = make-bb-bib-section ctx ctx-doc bibliography
    in
    bb-title +++ bb-inner +++ bb-bib-section +++ clear-page


  let section-scheme ctx label title inner =
    let ctx-title = make-section-title ctx in
    let () = increment num-section in
    let () = num-subsection <- 0 in
    let s-num = arabic (!num-section) in
    let () = register-cross-reference (`section:` ^ label ^ `:num`) s-num in
%    let () = toc-acc-ref <- (TOCElementSection(label, title)) :: !toc-acc-ref in
    let ib-num =
      read-inline ctx-title (embed-string (s-num ^ `.`))
        ++ hook-page-break (fun pbinfo _ ->
             register-cross-reference (`section:` ^ label ^ `:page`) (arabic pbinfo#page-number))
    in
    let ib-title = read-inline ctx-title title in
    let bb-title = section-heading ctx (ib-num ++ (inline-skip 10pt) ++ ib-title ++ (inline-fil)) in
    let bb-inner = read-block ctx inner in
      bb-title +++ bb-inner


  let subsection-scheme ctx label title inner =
    let () = num-subsection <- !num-subsection + 1 in
    let s-num = arabic (!num-section) ^ `.` ^ arabic (!num-subsection) in
    let () = register-cross-reference (`subsection:` ^ label ^ `:num`) s-num in
%    let () = toc-acc-ref <- (TOCElementSubsection(label, title)) :: !toc-acc-ref in
    let ctx-title = make-subsection-title ctx in
    let ib-num =
      read-inline ctx-title (embed-string (s-num ^ `.`))
        ++ hook-page-break (fun pbinfo _ ->
             register-cross-reference (`subsection:` ^ label ^ `:page`) (arabic pbinfo#page-number))
    in
    let ib-title = read-inline ctx-title title in
    let bb-title =
      line-break true false (ctx |> set-paragraph-margin section-top-margin section-bottom-margin)
        (ib-num ++ (inline-skip 10pt) ++ ib-title ++ (inline-fil))
    in
    let bb-inner = read-block ctx inner in
      bb-title +++ bb-inner

  let make-bb-toc-page ctx =
    let ib-toc-title =
      ctx
      |> make-chapter-title
      |> Inline.read {目次}
      |> align-ib-left
    in
    let bb-toc-title = (chapter-heading ctx None ib-toc-title)
    in
    let bb-toc-main = TableOfContents.make-bb toc-acc-ref ctx
    in
    Block.concat [
      bb-toc-title;
      bb-toc-main;
      clear-page;
      line-break false false (ctx |> set-paragraph-margin 0pt 0pt)
            (hook-page-break (fun pbinfo _ -> (show-page-number-ref <- Some(pbinfo#page-number))) ++ inline-fil);
    ]

  let make-bb-colophon-page record ctx =
    let bb-colophon = ctx |> Colophon.make-bb-colophon (|
      title     = record#title;
      date      = record#date;
      author    = record#author;
      email     = record#email;
      website   = record#website;
      publisher = record#publisher;
    |)
    in
    let bb-disable-page-number = ctx |> make-bb-disable-page-number
    in
    bb-colophon +++ bb-disable-page-number

  let pagecontf pbinfo =
    let () = FootnoteScheme.start-page () in
    let hgtfb = height-of-float-boxes pbinfo#page-number in
    let (text-origin-x, text-origin-y) = text-origin in
    (|
      text-origin = (text-origin-x, text-origin-y +' hgtfb);
      text-height = text-height -' hgtfb;
    |)

  let pagepartsf pbinfo =
    let pageno = pbinfo#page-number in
    let header =
      let ctx =
        get-standard-context header-width
          |> set-paragraph-margin 0pt 0pt
      in
      let (bb-float-boxes, acc) =
        (!ref-float-boxes) |> List.fold-left (fun (bbacc, acc) elem -> (
          let (pn, bb) = elem in
            if pn < pageno then
              let bbs =
                line-break true true (ctx |> set-paragraph-margin 0pt 12pt)
                  (inline-fil ++ embed-block-top ctx text-width (fun _ -> bb) ++ inline-fil)
                    % 'ctx' is a dummy context
              in
                (bbacc +++ bbs, acc)
            else
              (bbacc, elem :: acc)
        )) (block-nil, [])
      in
      let () = ref-float-boxes <- acc in
        bb-float-boxes
    in
    let footer =
      match !show-page-number-ref with
      | Some(pagenolast) ->
          let ctx = get-standard-context footer-width in
          let it-pageno = embed-string (arabic (pageno - pagenolast + 1)) in
            line-break true true ctx
              (inline-fil ++ (read-inline ctx {— #it-pageno; —}) ++ inline-fil)

      | None ->
          block-nil
    in
      (|
        header-origin  = header-origin;
        header-content = header;
        footer-origin  = footer-origin;
        footer-content = footer;
      |)

  let document record inner =
    let ctx-doc =
      get-standard-context text-width
        |> set-font-size 12pt
        |> set-leading 18pt
        |> set-hyphen-penalty 1000
    in
    let bb-title-pages = ctx-doc |> Title.make-bb (|
      title = record#title;
      date  = record#date;
      venue = record#venue;
    |)
    in
    let bb-main-pages = read-block ctx-doc inner
    in
    let bb-toc-pages = make-bb-toc-page ctx-doc
    in
    let bb-colophon-pages = make-bb-colophon-page record ctx-doc
    in
    page-break paper-size pagecontf pagepartsf
      (Block.concat [
        bb-title-pages;
        bb-toc-pages;
        bb-main-pages;
        bb-colophon-pages;
      ])


  let-block ctx +p inner =
    let len = get-font-size ctx *' font-ratio-cjk in
    let ib-inner = inline-skip len ++ read-inline ctx inner ++ inline-fil in
      form-paragraph ctx ib-inner

  let-block ctx +topic topic inner =
    let ctx-emph = ctx
      |> set-font Latin font-latin-sans
      |> set-cjk-font font-cjk-gothic in
    let ib-topic = read-inline ctx-emph topic in
    let len = get-font-size ctx *' font-ratio-cjk in
    let ib-inner = ib-topic ++ inline-skip len ++ read-inline ctx inner ++ inline-fil in
      form-paragraph ctx ib-inner

  let figure-scheme ctx labelopt prefix category caption inner =
    let () = num-figure <- !num-figure + 1 in
    let s-num = arabic !num-figure in
    let () =
      match labelopt with
      | Some(label) -> register-cross-reference (prefix ^ label ^ `:num`) s-num
      | None        -> ()
    in
    let it-num = embed-string s-num in
    let ctx-category =
      ctx |> set-font Latin font-latin-sans
          |> set-cjk-font font-cjk-gothic in
    let ib-caption =
      Inline.concat [
        ctx-category |> Inline.read {#category; #it-num;};
        Inline.skip (get-font-size ctx);
        ctx |> Inline.read caption
      ] in
    let bb-inner =
      let d (_, _) _ _ _ = [] in
      block-frame-breakable ctx (2pt, 2pt, 2pt, 2pt) (d, d, d, d) (fun ctx -> (
        (ctx |> Block.read inner) +++ (ctx |> Block.centering (Fn.const ib-caption))
      ))
    in
      hook-page-break (fun pbinfo _ -> (
%        let () = display-message (`register` ^ (arabic pbinfo#page-number)) in
        ref-float-boxes <- (pbinfo#page-number, bb-inner) :: !ref-float-boxes
      ))


  let-inline ctx \figure ?:labelopt caption inner =
    figure-scheme ctx labelopt `figure:` {図} caption inner


  let-inline ctx \table ?:labelopt caption inner =
    figure-scheme ctx labelopt `table:` {表} caption inner


  let-block ctx +chapter ?:labelopt ?:subtitle record inner =
    let label =
      match labelopt with
      | None        -> generate-fresh-label ()
      | Some(label) -> label
    in
      chapter-scheme ctx label record#bibliography record#title subtitle record#author inner


  let-block ctx +section ?:labelopt title inner =
    let label =
      match labelopt with
      | None        -> generate-fresh-label ()
      | Some(label) -> label
    in
      section-scheme ctx label title inner


  let-block ctx +subsection ?:labelopt title inner =
    let label =
      match labelopt with
      | None        -> generate-fresh-label ()
      | Some(label) -> label
    in
      subsection-scheme ctx label title inner


  let font-size-subsubsection = 14pt

  let make-subsubsection-title ctx =
      ctx |> set-font-size font-size-subsubsection
          |> set-font Latin font-latin-bold
          |> set-cjk-font font-cjk-gothic


  let-block ctx +subsubsection it bt =
    let ib-title =
      let ctx-title = make-subsubsection-title ctx in
      read-inline ctx-title it
    in
    let bb-title = line-break true false ctx (ib-title ++ inline-fil) in
    let bb-main = read-block ctx bt in
    bb-title +++ bb-main


  let-inline ctx \emph inner =
    let ctx-emph =
      ctx |> set-font Latin font-latin-sans
          |> set-cjk-font font-cjk-gothic
    in
      read-inline ctx-emph inner

  let-inline \dfn inner = {\emph{#inner;}}


  let theorem-scheme ctx ctxf category wordopt label inner =
    let () = increment num-theorems in
    let s-num =
      arabic (!num-theorems)
    in
    let () = register-cross-reference (label ^ `:num`) s-num in
    let it-num = embed-string s-num in
    let ib-dfn =
      let ctx =
        ctx |> set-latin-font font-latin-sans
            |> set-cjk-font font-cjk-gothic
      in
        read-inline ctx {#category; #it-num;}
    in
    let ib-word =
      match wordopt with
      | None       -> inline-nil
      | Some(word) -> read-inline ctx {\ (#word;)}
    in
    let ib-inner = read-inline (ctxf ctx) inner in
    let ib-diamond = read-inline (ctxf ctx) {\force-font(`ipaexg`){◇}} in
    let ib-glue = discretionary 0 inline-fil inline-nil inline-nil in
    line-break true true ctx
      (ib-dfn ++ ib-word ++ inline-skip (get-font-size ctx) ++ ib-inner ++ inline-fil
      ++ ib-glue ++ ib-diamond)

  let make-label prefix labelopt =
    match labelopt with
    | None    -> generate-fresh-label ()
    | Some(s) -> prefix ^ s


  let-block ctx +definition ?:wordopt ?:labelopt inner =
    let label = make-label `definition:` labelopt in
      theorem-scheme ctx (fun x -> x) {定義} wordopt label inner


  let-block ctx +theorem ?:wordopt ?:labelopt inner =
    let label = make-label `theorem:` labelopt in
      theorem-scheme ctx (set-latin-font font-latin-italic) {定理} wordopt label inner


  let-block ctx +lemma ?:wordopt ?:labelopt inner =
    let label = make-label `lemma:` labelopt in
      theorem-scheme ctx (set-latin-font font-latin-italic) {補題} wordopt label inner


  let-block ctx +corollary ?:wordopt ?:labelopt inner =
    let label = make-label `corollary:` labelopt in
      theorem-scheme ctx (set-latin-font font-latin-italic) {系} wordopt label inner



let-block ctx +hypothesis ?:wordopt ?:labelopt inner =
    let label = make-label `hypothesis:` labelopt in
      theorem-scheme ctx (set-latin-font font-latin-italic) {仮定} wordopt label inner



  let-block ctx +example ?:wordopt ?:labelopt inner =
    let label = make-label `example:` labelopt in
      theorem-scheme ctx (fun x -> x) {例} wordopt label inner

  let-block ctx +notation ?:wordopt ?:labelopt inner =
    let label = make-label `example:` labelopt in
      theorem-scheme ctx (fun x -> x) {記法} wordopt label inner

  let-math \QED = math-char MathOrd `∎`

  let-block ctx +proof ?:wordopt inner =
    let ib-heading =
      let ctx = ctx |> set-font Latin font-latin-sans
                    |> set-cjk-font font-cjk-gothic in
        match wordopt with
        | None    -> read-inline ctx {証明}
        | Some(w) -> read-inline ctx {#w; の証明}
    in
    let ib-box = read-inline ctx {${\QED}} in
      line-break true true ctx
        (ib-heading ++ inline-skip (get-font-size ctx) ++ read-inline ctx inner ++ inline-fil ++ ib-box)

  let-inline ctx \definition ?:wordopt ?:labelopt inner =
    inline-fil ++ embed-block-breakable ctx
      (read-block ctx (match (wordopt, labelopt) with
                       | (None, None) -> '<+definition(inner);>
                       | (Some(word), None) -> '<+definition?:(word)(inner);>
                       | (None, Some(label)) -> '<+definition?*?:(label)(inner);>
                       | (Some(word), Some(label)) -> '<+definition?:(word)?:(label)(inner);>
                       ))

  let-inline ctx \theorem ?:wordopt ?:labelopt inner =
    inline-fil ++ embed-block-breakable ctx
      (read-block ctx (match (wordopt, labelopt) with
                       | (None, None) -> '<+theorem(inner);>
                       | (Some(word), None) -> '<+theorem?:(word)(inner);>
                       | (None, Some(label)) -> '<+theorem?*?:(label)(inner);>
                       | (Some(word), Some(label)) -> '<+theorem?:(word)?:(label)(inner);>
                       ))

  let-inline ctx \lemma ?:wordopt ?:labelopt inner =
    inline-fil ++ embed-block-breakable ctx
      (read-block ctx (match (wordopt, labelopt) with
                       | (None, None) -> '<+lemma(inner);>
                       | (Some(word), None) -> '<+lemma?:(word)(inner);>
                       | (None, Some(label)) -> '<+lemma?*?:(label)(inner);>
                       | (Some(word), Some(label)) -> '<+lemma?:(word)?:(label)(inner);>
                       ))

  let-inline ctx \corollary ?:wordopt ?:labelopt inner =
    inline-fil ++ embed-block-breakable ctx
      (read-block ctx (match (wordopt, labelopt) with
                       | (None, None) -> '<+corollary(inner);>
                       | (Some(word), None) -> '<+corollary?:(word)(inner);>
                       | (None, Some(label)) -> '<+corollary?*?:(label)(inner);>
                       | (Some(word), Some(label)) -> '<+corollary?:(word)?:(label)(inner);>
                       ))

  let-inline ctx \hypothesis ?:wordopt ?:labelopt inner =
    inline-fil ++ embed-block-breakable ctx
      (read-block ctx (match (wordopt, labelopt) with
                       | (None, None) -> '<+hypothesis(inner);>
                       | (Some(word), None) -> '<+hypothesis?:(word)(inner);>
                       | (None, Some(label)) -> '<+hypothesis?*?:(label)(inner);>
                       | (Some(word), Some(label)) -> '<+hypothesis?:(word)?:(label)(inner);>
                       ))

  let-inline ctx \example ?:wordopt ?:labelopt inner =
    inline-fil ++ embed-block-breakable ctx
      (read-block ctx (match (wordopt, labelopt) with
                       | (None, None) -> '<+example(inner);>
                       | (Some(word), None) -> '<+example?:(word)(inner);>
                       | (None, Some(label)) -> '<+example?*?:(label)(inner);>
                       | (Some(word), Some(label)) -> '<+example?:(word)?:(label)(inner);>
                       ))

  let-inline ctx \notation ?:wordopt ?:labelopt inner =
    inline-fil ++ embed-block-breakable ctx
      (read-block ctx (match (wordopt, labelopt) with
                       | (None, None) -> '<+notation(inner);>
                       | (Some(word), None) -> '<+notation?:(word)(inner);>
                       | (None, Some(label)) -> '<+notation?*?:(label)(inner);>
                       | (Some(word), Some(label)) -> '<+notation?:(word)?:(label)(inner);>
                       ))

  let-inline ctx \proof ?:wordopt inner =
    inline-fil ++ embed-block-breakable ctx
      (read-block ctx (match wordopt with
                       | None -> '<+proof(inner);>
                       | Some(word) -> '<+proof?:(word)(inner);>
                       ))

  let get-number prefix label =
      match get-cross-reference (prefix ^ label ^ `:num`) with
      | None    -> {?}
      | Some(s) -> embed-string s


  let-inline ctx \ref-definition label =
    let it-num = get-number `definition:` label in
      read-inline ctx {定義 #it-num;}


  let-inline ctx \ref-theorem label =
    let it-num = get-number `theorem:` label in
      read-inline ctx {定理 #it-num;}


  let-inline ctx \ref-lemma label =
    let it-num = get-number `lemma:` label in
      read-inline ctx {補題 #it-num;}


  let-inline ctx \ref-corollary label =
    let it-num = get-number `corollary:` label in
      read-inline ctx {系 #it-num;}

  let-inline ctx \ref-hypothesis label =
    let it-num = get-number `hypothesis:` label in
      read-inline ctx {系 #it-num;}

  let-inline ctx \ref-example label =
    let it-num = get-number `example:` label in
      read-inline ctx {例 #it-num;}


  let generate-footnote-label n =
    `footnote:` ^ (arabic n)


  let promote-another-trial () =
    register-cross-reference `changed` `T`


  let-inline ctx \footnote it =
    let ibf num =
      let it-num = embed-string (arabic num) in
      let ctx =
        let size = get-font-size ctx in
          ctx |> set-font-size (size *' 0.75)
              |> set-manual-rising (size *' 0.25)
      in
        read-inline ctx {\*#it-num;}
    in
    let bbf num =
      let ib-num = read-inline ctx (embed-string (arabic num)) in
      let ctx =
        let size = 12pt in
          get-standard-context text-width
            |> set-font-size (size *' 0.9)
            |> set-leading (size *' 1.2)
            |> set-paragraph-margin (size *' 0.5) (size *' 0.5)
      in
      let len =
        let (w, _, _) = get-natural-metrics ib-num in
          footnote-indent -' w
      in
      let ib =
        ib-num ++ inline-skip len ++
          embed-block-top ctx (text-width -' footnote-indent) (fun ctx -> (
            line-break false false ctx (read-inline ctx it ++ inline-fil)
          ))
      in
        line-break false false ctx (ib ++ inline-fil)
    in
      FootnoteScheme.main ctx ibf bbf

end


let document = Book.document
  % ad-hoc
